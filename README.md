# 스마트 회생제동 시스템 (Smart Regenerative Braking System)

**현대오토에버 모빌리티 임베디드 SW 스쿨 4기 3차 프로젝트**  
**Team. 사파게티 (Sapaghetti)**

<br>

## 1. 📜 프로젝트 개요 (Overview)

본 프로젝트는 CANoe 기반의 가상 차량 환경에서 V2X 기술과 연계하여 전방 교통 상황을 예측하고, 이를 통해 회생제동 효율을 극대화하는 스마트 회생제동 시스템을 개발하는 것을 목표로 합니다.

기존의 회생제동 시스템은 운전자의 제동 의도나 도로 상황을 능동적으로 반영하지 못하고, 정해진 감도로만 동작하여 에너지 효율 손실과 제동 불안정성을 야기할 수 있습니다. 저희는 이러한 문제를 해결하기 위해, 차량의 주행 상황을 실시간으로 인지하고 센서 및 통신 데이터를 바탕으로 회생제동 강도를 동적으로 조절하는 지능형 시스템을 구현했습니다.

이를 통해 운전자에게는 향상된 주행 경험과 연비를, OEM에게는 차별화된 상품성을 제공하고자 합니다.

### ✨ 기대 효과

- **에너지 효율 극대화**: 주행 상황에 최적화된 제어로 배터리 충전 효율 및 주행 효율 증가
- **제동 안정성 및 승차감 향상**: 부드러운 제동력 제어로 울컥거림 없는 편안한 주행 경험 제공
- **친환경성 및 유지비 절감**: 에너지 재활용을 통한 친환경성 증대 및 유지비 절감
- **지속 가능한 성능 개선**: OTA(Over-the-Air) 기술을 통한 지속적인 제어 로직 업데이트 및 기능 추가

<br>

## 2. 🚀 주요 기능 (Key Features)

- **✅ 5단계 회생제동 모드**: Level 0 (기능 OFF), Level 1, Level 2, Level 3, 그리고 Auto 모드를 제공하여 운전자가 원하는 제동감을 선택할 수 있습니다.
- **🧠 지능형 'Auto' 모드**: V2X 통신으로 수신한 전방 신호등 정보, 도로 경사도 등 외부 데이터를 기반으로 회생제동 토크를 자동으로 조절합니다.
- **🎮 운전자 인터페이스 (HMI)**: 스티어링 휠 버튼, 음성 명령을 통해 손쉽게 모드를 변경하고, 디지털 클러스터를 통해 현재 모드, 배터리 상태, 에너지 회수량 등 주요 정보를 실시간으로 확인할 수 있습니다.
- **☁️ OTA (Over-the-Air) 업데이트**: 보안이 강화된 MQTT 프로토콜과 웹 서버를 통해 '편안한 모드'와 같은 새로운 기능이나 개선된 제어 로직을 안전하게 업데이트할 수 있습니다.
- **🛡 안전 및 보안 설계**: 기능 안전 표준 ISO 26262와 사이버 보안 표준 ISO/SAE 21434 요구사항을 반영하여 시스템의 오작동 및 외부 공격에 대비한 Fail-Safe, E2E 보호, Secure Boot 등의 메커니즘을 적용했습니다.

<br>

## 3. 🏗 시스템 아키텍처 (System Architecture)

본 시스템은 중앙 집중형 제어기인 HPC(High-Performance Computer)와 물리적 위치 기반의 Zonal ECU (Front, Center, Rear)로 구성된 Zonal 아키텍처를 기반으로 설계되었습니다. 외부 통신은 TMU(Telematics Management Unit)가 전담하며, 각 ECU는 CAN-FD 백본 네트워크를 통해 유기적으로 통신합니다.

### 주요 컴포넌트

- **HPC (High-Performance Computer)**: 시스템의 두뇌 역할. 회생제동 제어 전략 수립, V2X/OTA 데이터 처리, 마찰제동과의 블렌딩 로직 등 핵심 연산을 수행합니다.
- **ZCU (Zonal Control Unit)**: 각 Zone(Front, Center, Rear)에 위치하여 해당 영역의 센서 데이터 집계 및 액추에이터 제어를 담당합니다.
  - **ZCU_Front**: 가속/브레이크 페달, ADAS 센서 데이터 수집
  - **ZCU_Center**: 클러스터, 스티어링 휠 버튼, 음성인식 등 HMI 장치 인터페이스
  - **ZCU_Rear**: 모터(MCU), 배터리(BMS), 브레이크(IBC) 등 구동계 제어
- **TMU (Telematics Management Unit)**: V2X, OTA 등 외부 망과의 통신 게이트웨이 역할을 수행합니다.

<br>

## 4. 🛠 개발 환경 및 도구 (Development Environment & Tools)

| 구분 | 도구 | 목적 |
|------|------|------|
| 차량 네트워크 시뮬레이션 | CANoe | 가상 ECU 및 네트워크 환경 구축, CAPL 스크립트를 통한 로직 구현 |
| 제어 로직 개발 | MATLAB/Simulink | 회생제동 제어 알고리즘 및 모터 물리 모델 개발 |
| 하드웨어 연동 | Aurix Development Studio | TC275 보드 기반의 모터 제어 로직 구현 |
| 통합 개발 환경 | Visual Studio Code | Python 스크립트(OTA 클라이언트 등) 개발 |
| 네트워크 데이터베이스 | CANdb++ | CAN/CAN-FD 메시지 및 시그널 정의 |
| 프로젝트/산출물 관리 | Jira, Confluence | 애자일 스프린트, 요구사항 및 설계 문서 관리, 이슈 트래킹 |
| 형상 관리 | Git, GitHub | 소스 코드 버전 관리 및 협업 |
| CI/CD 및 자동화 | Jenkins | GitHub Webhook 연동을 통한 테스트 및 빌드 자동화 |
| 문서 자동화 | Doxygen | 소스 코드 주석 기반 설계 문서 자동 생성 |

<br>

## 5. ⚙️ 실행 방법 (Getting Started)

본 프로젝트는 CANoe 시뮬레이션 환경에서 실행됩니다.

### 1. 사전 준비
- Vector CANoe (11.0 이상) 설치
- Python (3.8 이상) 및 paho-mqtt 라이브러리 설치
- 프로젝트 리포지토리를 로컬에 Clone 합니다.

### 2. CANoe 환경 설정
- CANoe를 실행하고, 프로젝트에 포함된 Configuration.cfg 파일을 엽니다.
- 시뮬레이션 설정(Simulation Setup) 창에서 네트워크 노드(HPC, ZCU 등)가 정상적으로 로드되었는지 확인합니다.
- 필요한 DBC 파일이 올바르게 연결되었는지 확인합니다.

### 3. 시뮬레이션 실행
- CANoe 상단의 Start 버튼 (번개 모양)을 클릭하여 시뮬레이션을 시작합니다.
- 프로젝트에 포함된 Panel을 통해 가속/브레이크 페달을 조작하고, 회생제동 모드를 변경하며 클러스터의 변화를 관찰할 수 있습니다.

### 4. OTA 기능 실행 (선택 사항)
- ota_client/ 디렉토리의 Python 스크립트를 실행하여 OTA 업데이트 시나리오를 테스트할 수 있습니다. (서버 실행 필요)

<br>

## 6. 🧪 검증 (Verification)

본 프로젝트는 Automotive SPICE (A-SPICE) V-Model 개발 프로세스를 준수하여 체계적인 검증을 수행했습니다. vTESTstudio를 사용하여 요구사항 기반의 테스트 케이스를 작성하고, Jenkins를 통해 테스트 자동화를 구축했습니다.

- **단위 검증 (SWE.4)**: CAPL 함수 단위의 로직 정확성 검증 (경계값, 예외 처리 등)
- **통합 검증 (SWE.5)**: 이벤트 핸들러(메시지 수신 등)와 내부 함수 간의 연동 동작 검증
- **소프트웨어 검증 (SWE.6)**: 소프트웨어 요구사항 기반의 전체 기능 및 비기능(상태 전이, Fail-Safe 등) 동작 검증
- **CRC (Cyclic Redundancy Check)**: CAN 메시지 데이터의 무결성을 보장하기 위해 CRC 체크섬을 적용하고 검증했습니다.

<br>

## 7. 👥 팀원 및 역할 (Team & Roles)

| 이름 | 주요 담당 업무 |
|------|----------------|
| 송기종(PM) | 가상 ECU 개발, vTEST, 산출물 관리 |
| 안상우 | Simulink 모델링, HW 연동, 가상 ECU 개발 |
| 김혁순 | OTA 기능 개발, 발표 자료 제작 |
| 이예린 | Simulink 모델링, HW 연동, Jenkins 자동화 구축 |
| 조용일 | CANoe Panel, 가상 ECU 개발 |

<br>

## 8. 🤝 협업 규칙 (Collaboration Rules)

- **Branch 전략**: feature/, bugfix/, release/ 접두사를 사용하여 브랜치 목적을 명확히 합니다.
- **Commit 메시지**: `feat: 기능 설명 [Jira-ID]` 형식으로 작성하여 커밋 내역을 쉽게 추적할 수 있도록 합니다.
- **코드 리뷰**: 모든 코드는 main, develop 브랜치에 병합되기 전, Pull Request를 통해 동료 리뷰를 거칩니다.
- **Force Push 금지**: 코드 히스토리의 무결성을 위해 모든 브랜치에서 Force Push를 금지합니다.
- **자료 공유**: Discord를 메인 소통 채널로 사용하며, Jira, Confluence, GitHub 알림을 연동하여 개발 현황을 실시간으로 공유합니다.
