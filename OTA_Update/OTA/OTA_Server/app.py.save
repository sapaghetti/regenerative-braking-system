# app.py

from flask import Flask, request, abort, redirect, render_template, url_for, flash, send_from_directory, jsonify, session
from werkzeug.middleware.proxy_fix import ProxyFix
import os
import glob
import json
import bcrypt
import secrets
import hashlib
from flask_wtf import CSRFProtect
from datetime import timedelta, datetime
from login_form import LoginForm # login_form.py íŒŒì¼ì´ ìˆë‹¤ê³  ê°€ì •
from flask_session import Session # Flask-Sessionì´ ì„¤ì¹˜ë˜ì–´ ìˆë‹¤ê³  ê°€ì •
import logging
from logging.handlers import RotatingFileHandler
from werkzeug.utils import secure_filename
import sys
from pythonjsonlogger import jsonlogger
import time # íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš©ì„ ìœ„í•´ ì¶”ê°€
import re # íŒŒì¼ëª… íŒŒì‹±ì„ ìœ„í•œ ì •ê·œí‘œí˜„ì‹ ëª¨ë“ˆ ì¶”ê°€

# MQTT ë° ì•”í˜¸í™” ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€
import paho.mqtt.publish as publish
import struct
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.Random import get_random_bytes

# Google Cloud Secret Manager ê´€ë ¨ ì„í¬íŠ¸
from google.cloud import secretmanager

# --- ì¤‘ìš” ë³´ì•ˆ ê¶Œì¥ ì‚¬í•­ ---
# ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œëŠ” ë°˜ë“œì‹œ HTTPSë¥¼ ì ìš©í•˜ì—¬ ì„œë²„ì™€ ì°¨ëŸ‰ ê°„ì˜ í†µì‹ ì„ ì•”í˜¸í™”í•´ì•¼ í•©ë‹ˆë‹¤.
# ì´ëŠ” ë…¼ë¬¸ì—ì„œ ì–¸ê¸‰ëœ 'ê¸°ë°€ì„±(Confidentiality)' ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ê¸° ìœ„í•´ í•„ìˆ˜ì ì…ë‹ˆë‹¤.
# Flask ìì²´ ê°œë°œ ì„œë²„ëŠ” í”„ë¡œë•ì…˜ìš©ì´ ì•„ë‹ˆë¯€ë¡œ, Gunicorn, Nginx ë“±ì˜ WSGI ì„œë²„ì™€ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
# ---

app = Flask(__name__)
app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_host=1, x_prefix=1)

# TODO: ë³´ì•ˆ ê°•í™” - app.secret_keyëŠ” í™˜ê²½ ë³€ìˆ˜ë‚˜ Google Secret Managerë¥¼ í†µí•´ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.
# ì½”ë“œì— í•˜ë“œì½”ë”©í•˜ëŠ” ê²ƒì€ ë§¤ìš° ìœ„í—˜í•©ë‹ˆë‹¤.
app.secret_key = 'secret_key'
app.config['WTF_CSRF_SECRET_KEY'] = app.secret_key

csrf = CSRFProtect(app)

app.permanent_session_lifetime = timedelta(minutes=10)

UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'upload')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

USER_FILE = 'users.json'
VEHICLE_FILE = 'vehicles.json'
NONCE_FILE = 'nonces.json'
# TODO: ê²¬ê³ ì„± ë° ì•ˆì •ì„± - JSON íŒŒì¼ ëŒ€ì‹  PostgreSQL, MySQL ë“±ì˜ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ë„ì…í•´ì•¼ í•©ë‹ˆë‹¤.
# ì´ëŠ” ë°ì´í„°ì˜ ì§€ì†ì„±, ë¬´ê²°ì„±, ë™ì‹œì„± ì²˜ë¦¬ì— í•„ìˆ˜ì ì…ë‹ˆë‹¤.

AUDIT_LOG_FILE = 'audit.log'
audit_logger = logging.getLogger('audit')
audit_logger.setLevel(logging.INFO)

logHandler = RotatingFileHandler(AUDIT_LOG_FILE, maxBytes=5 * 1024 * 1024, backupCount=5)
formatter = jsonlogger.JsonFormatter('%(asctime)s %(levelname)s %(name)s %(message)s')
logHandler.setFormatter(formatter)
audit_logger.addHandler(logHandler)

# Nonce ë§Œë£Œ ì‹œê°„ ì„¤ì • (ì˜ˆ: 5ë¶„)
NONCE_EXPIRATION_SECONDS = 5 * 60 # 5ë¶„

# === MQTT ë¸Œë¡œì»¤ ì„¤ì • ===
# TODO: ì‹¤ì œ MQTT ë¸Œë¡œì»¤ ì£¼ì†Œì™€ í¬íŠ¸ë¡œ ë³€ê²½í•˜ì„¸ìš”!
MQTT_BROKER_HOST = "127.0.0.1"
MQTT_BROKER_PORT = 1883 # ì¼ë°˜ì ìœ¼ë¡œ ë¹„ë³´ì•ˆ MQTT í¬íŠ¸ (TLS/SSL ì‚¬ìš© ì‹œ 8883 ë“±)

# MQTT í† í”½ ì„¤ì •
MQTT_TOPIC_UPDATE_AVAILABLE = "ota/update/available" # ìƒˆ íŒì›¨ì–´ ì•Œë¦¼ í† í”½

# === íŒì›¨ì–´ ë³´ì•ˆ ì²˜ë¦¬ ê´€ë ¨ ì„¤ì •ê°’ ===
# make_bin_file_hybrid.pyì—ì„œ ê°€ì ¸ì˜´
MAGIC = 0xDEADBEEF
# TODO: ECU_ID ë° VERSIONì€ íŒŒì¼ëª…ì—ì„œ ë™ì ìœ¼ë¡œ ê°€ì ¸ì˜¤ë„ë¡ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.
# ë”°ë¼ì„œ DEFAULT_ECU_ID ë° DEFAULT_VERSION ë³€ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

# íŒŒì¼ëª…ì—ì„œ ECU_IDì™€ VERSIONì„ ì¶”ì¶œí•˜ê¸° ìœ„í•œ ì •ê·œ í‘œí˜„ì‹
# ì˜ˆ: firmware_ECU03_V06.bin
FILENAME_PATTERN = re.compile(r'.*ECU(\d+)_V(\d+)\.bin$')

# === Google Cloud Secret Manager ì„¤ì • ===
# TODO: ì—¬ê¸°ì— ë‹¹ì‹ ì˜ GCP í”„ë¡œì íŠ¸ IDë¥¼ ì…ë ¥í•˜ì„¸ìš”!
GCP_PROJECT_ID = "thematic-grin-463106-m2"
SERVER_PRIVATE_KEY_SECRET_ID = "ota-server-private-key" # Secret Managerì— ì €ì¥í•œ ì„œë²„ ê°œì¸í‚¤ ë¹„ë°€ ì´ë¦„
VEHICLE_PUBLIC_KEY_FILE = "public.pem" # ì°¨ëŸ‰ì˜ ê³µê°œí‚¤ íŒŒì¼ ê²½ë¡œ

# ì „ì—­ ë³€ìˆ˜ë¡œ í‚¤ ì¸ìŠ¤í„´ìŠ¤ ì €ì¥ (ìµœì´ˆ 1íšŒ ë¡œë“œ í›„ ì¬ì‚¬ìš©)
_server_private_key = None
_vehicle_public_key = None

def write_audit_log(event, status="SUCCESS", **kwargs):
    # ê³µí†µ í•„ë“œ
    log_data = {
        "event": event,
        "status": status,
        "timestamp": datetime.now().isoformat(),
        "ip": request.remote_addr
    }
    
    # ì„¸ì…˜ ì •ë³´ (ë¡œê·¸ì¸ ë˜ì–´ ìˆì„ ê²½ìš°)
    if session.get('logged_in'):
        log_data["user"] = session.get('username')
        log_data["role"] = session.get('role')

    # 'filename' ëŒ€ì‹  'file_name' ì‚¬ìš©
    if 'filename' in kwargs:
        kwargs['file_name'] = kwargs.pop('filename')
    
    # ì¶”ê°€ì ì¸ kwargs í•„ë“œ í¬í•¨
    log_data.update(kwargs)

    audit_logger.info("Audit log entry", extra=log_data)

def load_users():
    if not os.path.exists(USER_FILE):
        initial_users = {
            "admin": {"password": bcrypt.hashpw("admin_password".encode('utf-8'), bcrypt.gensalt()).decode('utf-8'), "role": "admin"}
        }
        with open(USER_FILE, 'w') as f:
            json.dump(initial_users, f, indent=4)
    with open(USER_FILE, 'r') as f:
        return json.load(f)

def load_vehicles():
    if not os.path.exists(VEHICLE_FILE):
        sample_vehicles = {
            "Sapaghetti": {
                "token": "SECRET_API_KEY_FOR_Sapaghetti_VEHICLE"
            }
        }
        with open(VEHICLE_FILE, 'w') as f:
            json.dump(sample_vehicles, f, indent=4)
        return sample_vehicles
    with open(VEHICLE_FILE, 'r') as f:
        return json.load(f)

def load_nonces():
    if not os.path.exists(NONCE_FILE):
        return {}
    try:
        with open(NONCE_FILE, 'r') as f:
            content = f.read()
            if not content:
                return {}
            return json.loads(content)
    except json.JSONDecodeError as e:
        print(f"[ERROR] nonces.json íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}. íŒŒì¼ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.", file=sys.stderr)
        return {}

def save_nonces(nonces_data):
    with open(NONCE_FILE, 'w') as f:
        json.dump(nonces_data, f, indent=4)

def load_server_private_key():
    """
    Google Secret Manager ë˜ëŠ” ë¡œì»¬ íŒŒì¼ì—ì„œ ì„œë²„ì˜ ê°œì¸ í‚¤ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
    """
    global _server_private_key
    if _server_private_key:
        return _server_private_key # ì´ë¯¸ ë¡œë“œëœ í‚¤ ì¬ì‚¬ìš©

    try:
        print("ğŸŒ Secret Managerì—ì„œ ì„œë²„ ê°œì¸í‚¤ë¥¼ ë¡œë“œ ì‹œë„ ì¤‘...")
        client = secretmanager.SecretManagerServiceClient()
        name = f"projects/{GCP_PROJECT_ID}/secrets/{SERVER_PRIVATE_KEY_SECRET_ID}/versions/latest"
        response = client.access_secret_version(request={"name": name})
        server_private_key_pem = response.payload.data.decode("utf-8")
        _server_private_key = RSA.import_key(server_private_key_pem)
        print("âœ… ì„œë²„ ê°œì¸í‚¤ë¥¼ Secret Managerì—ì„œ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        print(f"âŒ Secret Managerì—ì„œ ì„œë²„ ê°œì¸í‚¤ë¥¼ ë¡œë“œí•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {e}")
        print("â— ëŒ€ì²´: ë¡œì»¬ íŒŒì¼ 'private.pem'ì—ì„œ ê°œì¸í‚¤ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤. ì´ ë°©ì‹ì€ ìš´ì˜ í™˜ê²½ì—ì„œ ê¶Œì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        if not os.path.exists("private.pem"):
            print("âŒ ë¡œì»¬ 'private.pem' íŒŒì¼ë„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê°œì¸í‚¤ ì—†ì´ëŠ” íŒì›¨ì–´ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return None
        with open("private.pem", "rb") as f:
            _server_private_key = RSA.import_key(f.read())
        print("âœ… ë¡œì»¬ 'private.pem'ì—ì„œ ê°œì¸í‚¤ë¥¼ ë¡œë“œí–ˆìŠµë‹ˆë‹¤. (ë³´ì•ˆ ê²½ê³ !)")
    return _server_private_key

def load_vehicle_public_key():
    """
    ë¡œì»¬ íŒŒì¼ì—ì„œ ì°¨ëŸ‰ì˜ ê³µê°œ í‚¤ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
    """
    global _vehicle_public_key
    if _vehicle_public_key:
        return _vehicle_public_key # ì´ë¯¸ ë¡œë“œëœ í‚¤ ì¬ì‚¬ìš©

    if not os.path.exists(VEHICLE_PUBLIC_KEY_FILE):
        print(f"âŒ '{VEHICLE_PUBLIC_KEY_FILE}' íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì°¨ëŸ‰ì˜ ê³µê°œí‚¤ íŒŒì¼ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.")
        return None
    with open(VEHICLE_PUBLIC_KEY_FILE, "rb") as f:
        _vehicle_public_key = RSA.import_key(f.read())
    print(f"âœ… '{VEHICLE_PUBLIC_KEY_FILE}'ì—ì„œ ì°¨ëŸ‰ì˜ ê³µê°œí‚¤ë¥¼ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.")
    return _vehicle_public_key

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    users = load_users()
    if form.validate_on_submit():
        username = form.username.data
        password = form.password.data.encode('utf-8')
        if username in users:
            stored_hash = users[username]['password'].encode('utf-8')
            if bcrypt.checkpw(password, stored_hash):
                session.permanent = True
                session['logged_in'] = True
                session['username'] = username
                session['role'] = users[username]['role']
                write_audit_log(event="LOGIN", status="SUCCESS", user=username)
                return redirect(url_for('upload_form'))
        
        write_audit_log(event="LOGIN", status="FAILURE", user=username)
        return redirect(url_for('login', error='1', prev_username=username))    
    
    prev_username = request.args.get('prev_username')
    if prev_username:
        form.username.data = prev_username
    return render_template('login.html', form=form)

@app.route('/logout')
def logout():
    write_audit_log(event="LOGOUT", user=session.get('username'))
    session.pop('logged_in', None)
    session.pop('username', None)
    session.pop('role', None)
    return redirect(url_for('login'))

@app.route('/')
def upload_form():
    if not session.get('logged_in'):
        return redirect(url_for('login'))
    # íŒŒì¼ ëª©ë¡ì„ ì „ë‹¬í•˜ì—¬ upload.htmlì— í‘œì‹œ
    firmware_files = glob.glob(os.path.join(app.config['UPLOAD_FOLDER'], '*_secure_hybrid.bin'))
    # íŒŒì¼ëª…ë§Œ ì¶”ì¶œí•˜ì—¬ ì „ë‹¬
    files = [os.path.basename(f) for f in firmware_files]
    return render_template('upload.html', files=files) # files ë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ì—¬ ì „ë‹¬


